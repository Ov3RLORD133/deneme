# KeyChaser - Malware C2 Sinkhole & Traffic Emulation Framework

![Version](https://img.shields.io/badge/version-1.0.0-blue)
![Python](https://img.shields.io/badge/python-3.11+-green)
![License](https://img.shields.io/badge/license-Research-orange)

**KeyChaser** is an advanced malware C2 sinkhole and traffic emulation framework designed for security researchers to intercept, decrypt, and analyze network traffic generated by keyloggers, RATs, and other malware families in isolated lab environments.

## ğŸš¨ **Legal Disclaimer**

**FOR AUTHORIZED RESEARCH ONLY.** This tool is designed exclusively for:
- Malware analysis in controlled lab environments
- Security research with proper authorization
- Educational purposes in cybersecurity training

**DO NOT** use this tool for:
- Unauthorized interception of communications
- Accessing systems without explicit permission
- Any activities that violate applicable laws

Users are solely responsible for compliance with all applicable laws and regulations.

---

## âœ¨ Features

- **ğŸ”Œ Modular Protocol Handlers**: Plugin-based architecture for supporting multiple malware families
- **ğŸ” Multi-Algorithm Decryption**: Built-in support for XOR, RC4, and AES decryption
- **ğŸ“Š Real-Time Dashboard**: Dark-themed web interface for monitoring live infections
- **ğŸ’¾ SQLite Database**: Portable storage for bots, keystrokes, and credentials
- **âš¡ Async Architecture**: Non-blocking I/O with `asyncio` for high-performance concurrent connections
- **ğŸ” Traffic Analysis**: Hexdump utilities and structured logging for forensic review
- **ğŸ‹ Docker Support**: Containerized deployment with docker-compose

---

## ğŸ—ï¸ Architecture

```
KeyChaser/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ api/              # REST endpoints for dashboard
â”‚   â”‚   â”œâ”€â”€ bots.py       # Bot management API
â”‚   â”‚   â”œâ”€â”€ logs.py       # Keystroke logs API
â”‚   â”‚   â””â”€â”€ stats.py      # Statistics & analytics
â”‚   â”œâ”€â”€ core/             # Core infrastructure
â”‚   â”‚   â”œâ”€â”€ config.py     # Pydantic settings
â”‚   â”‚   â”œâ”€â”€ database.py   # SQLAlchemy async setup
â”‚   â”‚   â””â”€â”€ logging.py    # Structured logging
â”‚   â”œâ”€â”€ models/           # Database models
â”‚   â”‚   â”œâ”€â”€ bot.py        # Infected machine records
â”‚   â”‚   â”œâ”€â”€ log.py        # Keystroke/activity logs
â”‚   â”‚   â””â”€â”€ credential.py # Stolen credentials
â”‚   â”œâ”€â”€ protocols/        # Protocol handlers (PLUGIN SYSTEM)
â”‚   â”‚   â”œâ”€â”€ base.py       # Abstract base class
â”‚   â”‚   â”œâ”€â”€ utils.py      # Crypto & parsing utilities
â”‚   â”‚   â””â”€â”€ example_logger.py  # Example handler
â”‚   â”œâ”€â”€ static/           # CSS/JS assets
â”‚   â”œâ”€â”€ templates/        # Jinja2 templates
â”‚   â”‚   â””â”€â”€ dashboard.html
â”‚   â””â”€â”€ main.py           # Application entry point
â”œâ”€â”€ data/                 # Database & logs (auto-created)
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ requirements.txt
â””â”€â”€ README.md
```

---

## ğŸš€ Quick Start

### Prerequisites

- **Python 3.11+**
- **pip** (Python package manager)
- **Docker** (optional, for containerized deployment)

### Installation

1. **Clone the repository:**
   ```bash
   git clone <repository-url>
   cd KeyChaser
   ```

2. **Install dependencies:**
   ```bash
   pip install -r requirements.txt
   ```

3. **Run the application:**
   ```bash
   python -m app.main
   ```

4. **Access the dashboard:**
   Open your browser to `http://localhost:8000`

### Docker Deployment

```bash
docker-compose up -d
```

This will:
- Build the KeyChaser container
- Expose ports 8000 (dashboard), 4444 (example protocol), and additional ports for future handlers
- Mount volumes for persistent data

---

## ğŸ”§ Configuration

Configuration is managed via **Pydantic Settings** and can be overridden with environment variables:

| Environment Variable | Default | Description |
|---------------------|---------|-------------|
| `KEYCHASER_HOST` | `0.0.0.0` | Server bind address |
| `KEYCHASER_API_PORT` | `8000` | Dashboard port |
| `KEYCHASER_DB_PATH` | `data/keychaser.db` | SQLite database path |
| `KEYCHASER_LOG_PATH` | `data/logs` | Log directory |
| `KEYCHASER_LOG_LEVEL` | `INFO` | Logging verbosity |
| `KEYCHASER_ENABLED_PROTOCOLS` | `["example_logger"]` | Active protocol handlers |

**Example `.env` file:**
```env
KEYCHASER_HOST=0.0.0.0
KEYCHASER_API_PORT=8000
KEYCHASER_LOG_LEVEL=DEBUG
KEYCHASER_ENABLED_PROTOCOLS=["example_logger","agent_tesla"]
```

---

## ğŸ§© Creating Protocol Handlers

To add support for a new malware family, create a new file in `app/protocols/`:

```python
# app/protocols/my_malware.py

from app.protocols.base import ProtocolHandler
from app.protocols.utils import rc4_decrypt, extract_delimited_strings

class MyMalwareHandler(ProtocolHandler):
    """Handler for MyMalware keylogger."""
    
    @property
    def name(self) -> str:
        return "MyMalware"
    
    @property
    def port(self) -> int:
        return 5555  # Port to listen on
    
    async def decrypt(self, data: bytes) -> bytes:
        """Decrypt using RC4 with hardcoded key."""
        return rc4_decrypt(data, b"HardcodedKey123")
    
    async def parse(self, decrypted_data: bytes, client_info: dict) -> dict:
        """Parse decrypted payload."""
        fields = extract_delimited_strings(decrypted_data, b"|")
        
        return {
            "bot_info": {
                "ip_address": client_info["ip"],
                "port": client_info["port"],
                "protocol": self.name,
                "bot_id": fields[0],
                "hostname": fields[1],
                # ... additional fields
            },
            "logs": [
                {
                    "log_type": "keystroke",
                    "keystroke_data": fields[4],
                    # ... additional fields
                }
            ],
            "credentials": [],
        }
```

Then enable it in your configuration:
```bash
export KEYCHASER_ENABLED_PROTOCOLS='["example_logger","my_malware"]'
```

---

## ğŸ“¡ API Endpoints

### Bots
- `GET /api/bots` - List infected bots
- `GET /api/bots/{id}` - Get bot details
- `GET /api/bots/count` - Count bots
- `DELETE /api/bots/{id}` - Delete bot

### Logs
- `GET /api/logs` - List keystroke logs
- `GET /api/logs/{id}` - Get log details
- `GET /api/logs/search?keyword=password` - Search logs
- `GET /api/logs/count` - Count logs

### Statistics
- `GET /api/stats/overview` - Dashboard overview
- `GET /api/stats/timeline?hours=24` - Infection timeline
- `GET /api/stats/top_ips` - Top victim IPs
- `GET /api/stats/protocols` - Per-protocol statistics

---

## ğŸ›¡ï¸ Security Considerations

1. **Isolated Environment**: Always run KeyChaser in an isolated lab network
2. **Access Control**: Restrict dashboard access with firewall rules
3. **Data Handling**: Treat captured data as sensitive - encrypt storage if needed
4. **Rate Limiting**: Built-in connection limits prevent DoS attacks
5. **Legal Compliance**: Ensure you have authorization before deploying

---

## ğŸ§ª Testing

To test the example protocol handler, use the provided test script:

```python
import socket

# Connect to example logger port
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('localhost', 4444))

# Send XOR-encrypted payload
payload = "BOT001|DESKTOP-PC|user123|Windows 10|Chrome - Gmail|user@example.com[TAB]password123[ENTER]"
key = b"SecretKey123"
encrypted = bytes(payload.encode()[i] ^ key[i % len(key)] for i in range(len(payload)))

sock.send(encrypted)
response = sock.recv(1024)
sock.close()

print(f"Server response: {response}")
```

---

## ğŸ“ Logging

KeyChaser uses structured logging with two output streams:

1. **Application Logs**: `data/logs/keychaser_YYYYMMDD.log`
   - API requests, database operations, errors
   
2. **Traffic Logs**: `data/logs/traffic.log`
   - Raw hexdumps of encrypted traffic
   - Decrypted payloads for forensic analysis

---

## ğŸ¤ Contributing

Contributions are welcome! To add support for a new malware family:

1. Reverse-engineer the malware's network protocol
2. Create a new handler in `app/protocols/`
3. Test in an isolated environment
4. Submit a pull request with documentation

---

## ğŸ“š References

- [FastAPI Documentation](https://fastapi.tiangolo.com/)
- [SQLAlchemy Async](https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.html)
- [Python asyncio](https://docs.python.org/3/library/asyncio.html)
- [Malware Traffic Analysis](https://www.malware-traffic-analysis.net/)

---

## ğŸ“„ License

This project is provided for **research and educational purposes only**. See the Legal Disclaimer section for details.

---

## ğŸ™ Acknowledgments

Built with â¤ï¸ for the cybersecurity research community.

**Stay safe. Stay legal. Happy hunting!** ğŸ”
